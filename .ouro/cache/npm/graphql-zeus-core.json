{"pkg":"graphql-zeus-core","readme":"# Zeus | GraphQL TypeScript generator\n\nStrongly Typed GraphQL from the team at [GraphQL Editor](https://graphqleditor.com/)\n\nGraphQL Zeus is the absolute best way to interact with your GraphQL endpoints in a type-safe way. Zeus uses your schema to generate Typescript types and strongly typed clients to unlock the power, efficiency, productivity and safety of Typescript on your GraphQL requests.\n\n## Features\n\n⚡️ Types mapped from your schema\\\n⚡️ Works with Apollo Client, React Query, Stucco Subscriptions _(\\*more coming soon...)_\\\n⚡️ Works with Subscriptions\\\n⚡️ Allows inferring complex response types\\\n⚡️ Creates reusable selection sets (like fragments) for use across multiple queries\\\n⚡️ Supports GraphQL Unions, Interfaces, Aliases and Variables\\\n⚡️ Handles **massive** schemas\\\n⚡️ Supports Browsers, Node.js and React Native in Javascript and Typescript\\\n⚡️ Has a schema downloader\\\n⚡️ Supports JSON schema generation\\\n\n## Getting Started | Zeus GraphQL TypeScript generator\n\nUse the Zeus CLI to generate types and GraphQL clients based on your schema, which you can then import into your projects to autocomplete, query and use GraphQL responses in a type-safe way.\n\n# Zeus Spec\n\nTo return the promise of type query for data object:\n\n```\nPROMISE_RETURNING_OBJECT = Chain.[OPERATION_NAME]({\n    ...FUNCTION_FIELD_PARAMS\n})(\n    ...QUERY_OBJECT\n).then ( RESPONSE_OBJECT => RESPONSE_OBJECT[OPERATION_FIELD] )\n```\n\nThe simple command for object function params:\n\n```\nFUNCTION_FIELD_PARAMS = {\n  KEY: VALUE\n}\n```\n\nQuery object:\n\n```\nQUERY_OBJECT = {\n    ...RETURN_PARAMS\n}\n```\n\nReturn params is an object containing RETURN_KEY - true if it is a `scalar`, RETURN_PARAMS if `type`. Otherwise it is a function where you pass field params and type return params.\n\n```\nRETURN_PARAMS = {\n    RETURN_KEY: true,\n    RETURN_KEY: {\n        ...RETURN_PARAMS\n    },\n    RETURN_FUNCTION_KEY:[\n        {\n            ...FUNCTION_FIELD_PARAMS\n        },\n        {\n            ...RETURN_PARAMS\n        }\n    ]\n}\n```\n\n### Use Alias Spec\n\n```\nRETURN_PARAMS = {\n  __alias: RETURN_PARAMS\n}\n```\n\nAccess aliased operation in a type-safe way:\n\n```\nPROMISE_RETURNING_OBJECT[ALIAS_STRING]\n```\n\n\n## Usage\n\nGenerated code from TranslateToTS specification\n\n### Tip:\n\nAdd a script entry in your `package.json` file for quickly calling Zeus generation:\n\n```json\n\"scripts\": {\n//...\n\"generate\": \"zeus https://faker.graphqleditor.com/a-team/olympus/graphql zeusGenerated --typescript --header='My-Auth-Secret:JsercjjJY5MmghtHww6UF' --apollo\"\n},\n```\n\n## Demo Endpoint\n\nAll demo code here is using the demo GraphQL endpoint of [Olympus Cards](https://app.graphqleditor.com/a-team/olympus){rel=\"nofollow\"} built with [GraphQL Editor](https://graphqleditor.com/). Feel free to check out the [GraphiQL interface](https://faker.graphqleditor.com/a-team/olympus/graphql){rel=\"nofollow\"} too.\n\n## Query With Zeus Chain Client\n\nYou can now use the Zeus `Chain` client from the generated output to make type-safe queries and mutations to your endpoint and receive type-safe responses.\n\n```ts\nimport { Chain } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\n\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst listCardsAndDraw = await chain('query')({\n  cardById: [\n    {\n      cardId: 'da21ce0a-40a0-43ba-85c2-6eec2bf1ae21',\n    },\n    {\n      name: true,\n      description: true,\n    },\n  ],\n  listCards: {\n    name: true,\n    skills: true,\n    attack: [\n      {\n        cardID: [\n          '66c1af53-7d5e-4d89-94b5-1ebf593508f6',\n          'fc0e5757-4d8a-4f6a-a23b-356ce167f873',\n        ],\n      },\n      {\n        name: true,\n      },\n    ],\n  },\n  drawCard: {\n    name: true,\n    skills: true,\n    Attack: true,\n  },\n});\n// listCardsAndDraw is now typed as the response of the query.\n```\n\nWhen querying a GraphQL field that takes an argument like `cardById` above, the fields are defined in terms of a tuple for example: cardById: `[ {...arguments} , {...response_selection_set} ]` and the equivalent in gql syntax would be:\n\n```text\ncardById (cardId: \"da21ce0a-40a0-43ba-85c2-6eec2bf1ae21\") {\n  name\n  description\n}\n```\n\nFor fields that have no argument, they receive only the response selection set object values.\n\nNote: `Chain` will also accept a second argument of fetch-like options to configure the client with properties such as `credentials`, `mode`, `headers` etc...\n\nNote: There is also an exported Zeus `Gql` convenience function in a `Chain` client, pre-configured with the endpoint specified in the CLI.\n\n## Listen on a WebSocket - GraphQL Subscriptions\n\nUse the Zeus `Subscription` client creator in your generated output to create WebSocket connections to your GraphQL socket.\n\n```ts\nimport { Subscription } from './zeus';\n\n// Create a Subscription client instance with the endpoint\nconst sub = Subscription(\n  'https://faker.graphqleditor.com/a-team/olympus/graphql',\n);\n\n// Call the client instance and listen for responses\nsub('subscription')({\n  deck: {\n    id: true,\n  },\n}).on((response) => {\n  console.log(response.deck);\n});\n```\n\n# Selectors | Zeus GraphQL TypeScript generator\n\n### Generate Reusable Selection Sets\n\nIn TypeScript Zeus can help you make type-safe Zeus selection sets to reuse across queries.\n\n```typescript\nimport { Selector, Chain } from './zeus';\n\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\n\nconst cardSelector = Selector('Card')({\n  name: true,\n  description: true,\n  Attack: true,\n  skills: true,\n  Defense: true,\n  cardImage: {\n    key: true,\n    bucket: true,\n  },\n});\n\nconst queryWithSelectionSet = await chain('query')({\n  drawCard: cardSelector,\n});\n```\n\n### Inferring the response type\n\nSometimes you might want to infer the response type. In that case, it is best to use selectors:\n\n```tsx\nimport { Selector, InputType, GraphQLTypes } from './zeus';\n\nexport const drawCardQuery = Selector(\"Query\"){\n  drawCard: {\n    Attack: true,\n    Children: true,\n    id: true,\n  },\n});\n\ntype InferredResponseType = InputType<GraphQLTypes['Query'], typeof drawCardQuery>;\n```\n\n# Custom fetch\n\nUse the Zeus `Thunder` to get total control over the fetch function and ensure you won't lose the result type. ⚡️\n\n```typescript\nimport { Thunder } from './zeus';\n\n// Create thunder fetch client with endpoint, options and response handlers\nconst thunder = Thunder(async (query) => {\n  const response = await fetch(\n    'https://faker.graphqleditor.com/a-team/olympus/graphql',\n    {\n      body: JSON.stringify({ query }),\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    },\n  );\n\n  if (!response.ok) {\n    return new Promise((resolve, reject) => {\n      response\n        .text()\n        .then((text) => {\n          try {\n            reject(JSON.parse(text));\n          } catch (err) {\n            reject(text);\n          }\n        })\n        .catch(reject);\n    });\n  }\n\n  const json = await response.json();\n\n  return json.data;\n});\n\n// Call thunder client with type-safe arguments, fields and get type-safe result type\nconst listCardsAndDraw = await thunder('query')({\n  cardById: [\n    {\n      cardId: 'sdsd',\n    },\n    {\n      description: true,\n    },\n  ],\n  listCards: {\n    name: true,\n    skills: true,\n    attack: [\n      { cardID: ['s', 'sd'] },\n      {\n        name: true,\n      },\n    ],\n  },\n  drawCard: {\n    name: true,\n    skills: true,\n    Attack: true,\n  },\n});\n```\n\n# Interfaces and Unions\n\n### GraphQL Unions\n\nYou can use Zeus with [GraphQL Unions](https://spec.graphql.org/June2018/#sec-Unions):\n\n```typescript\nconst { drawChangeCard } = await chain('query')({\n  drawChangeCard: {\n    __typename: true,\n    '...on EffectCard': {\n      effectSize: true,\n      name: true,\n    },\n    '...on SpecialCard': {\n      effect: true,\n      name: true,\n    },\n  },\n});\n```\n\nand it will give you this response:\n\n```json\n{\n  \"effectSize\": 195.99532210956377,\n  \"name\": \"Destinee\",\n  \"__typename\": \"EffectCard\"\n}\n```\n\n### GraphQL Interfaces\n\nZeus also works with [GraphQL Interfaces](http://spec.graphql.org/June2018/#sec-Interfaces)\n\n```typescript\nconst { nameables } = await Gql('query')({\n  nameables: {\n    __typename: true,\n    name: true,\n    '...on CardStack': {\n      cards: {\n        Defense: true,\n      },\n    },\n    '...on Card': {\n      Attack: true,\n    },\n  },\n});\n```\n\ngiving the following response:\n\n```json\n{\n  \"nameables\": [\n    {\n      \"__typename\": \"EffectCard\",\n      \"name\": \"Hector\"\n    },\n    {\n      \"__typename\": \"CardStack\",\n      \"name\": \"Scotty\",\n      \"cards\": [\n        {\n          \"Defense\": 1950\n        },\n        {\n          \"Defense\": 76566\n        }\n      ]\n    },\n    {\n      \"__typename\": \"SpecialCard\",\n      \"name\": \"Itzel\"\n    }\n  ]\n}\n```\n\n# Aliases \n\nZeus supports declaring aliases by using:\n\n```graphql\nconst aliasedQueryExecute = await chain('query')({\n  listCards: {\n    __alias: {\n      atak: {\n        attack: [\n          { cardID: ['1'] },\n          {\n            name: true,\n            description: true,\n          },\n        ],\n      },\n    },\n  },\n});\n```\n\nand this is the response:\n\n```json\n{\n  \"listCards\": [\n    {\n      \"atak\": [\n        {\n          \"name\": \"Zelma\",\n          \"description\": \"Central\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nNow you can access properties in a type-safe way like this:\n\n```javascript\naliasedQueryExecute.listCards.map((c) => c.atak);\n```\n\n# Directives\n\nZeus supports using directives on fields.\n\n```typescript\nimport { Chain } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\n\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst listCardsAndDraw = await chain('query')({\n  drawCard: {\n    name: true,\n    skills: true,\n    Attack: `@skip(if: true)`,\n  },\n});\n```\n\nremember that you need to put in the full string instead of `true`.\n\n## Use on object field\n\nUse directive on `drawCard`\n\n```ts\nimport { Chain } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\n\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst listCardsAndDraw = await chain('query')({\n  drawCard: {\n    __directives: `@skip(if:true)`,\n    name: true,\n    skills: true,\n  },\n});\n```\n\n## Use on function\n\n```ts\nimport { Chain } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\n\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst listCardsAndDraw = await chain('query')({\n  drawCard: {\n    name: true,\n    skills: true,\n    attack: [\n      {\n        cardId: ['2312321'],\n      },\n      {\n        __directives: `@skip(if:true)`,\n        name: true,\n        skills: true,\n      },\n    ],\n  },\n});\n```\n\n## Use it with variables\n\n```ts\nimport { Chain } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\nconst variables = useZeusVariables({\n    isDefense: 'Boolean!'\n})({\n    isDefense:true\n});\nconst { $ } = variables;\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst listCardsAndDraw = await chain('query')({\n  drawCard: {\n    name: true,\n    skills: true,\n    Attack: `@skip(if: ${$('isDefense')})`,\n  },\n  {\n      variables\n  }\n});\n```\n\n# Variables \n\nIt's simple to perform queries with variables by using the `useZeusVariables` function. It also forces you to be type-safe.\n\n```ts\nimport { Gql, $ } from './zeus';\n\nconst addCardResult = await Gql('mutation')(\n  {\n    addCard: [\n      {\n        card: $('card'),\n      },\n      {\n        id: true,\n        description: true,\n        name: true,\n        Attack: true,\n        skills: true,\n        Children: true,\n        Defense: true,\n        cardImage: {\n          bucket: true,\n          region: true,\n          key: true,\n        },\n      },\n    ],\n  },\n  {\n    variables: {\n      Attack: 2,\n      Defense: 3,\n      description: 'Lord of the mountains',\n      name: 'Golrog',\n    },\n  },\n);\n```\n\n## TypedDocumentNode + Apollo Client useMutation examples\n\nThe following example demonstrates usage with Apollo. Other clients should work similarly.\n\n```tsx\nimport { typedGql } from './zeus/typedDocumentNode';\nimport { $ } from './zeus';\nimport { useMutation } from '@apollo/client';\n\nconst myMutation = typedGql('mutation')({\n  cardById: [{ cardId: $('cardId', 'String!') }, { name: true }],\n});\n\nconst Main = () => {\n  const [mutate] = useMutation(myMutation);\n  // data response is typed\n  return (\n    <div\n      onClick={() => {\n        // this are typesafe vars\n        mutate({\n          variables: {\n            cardId: 'du1hn298u1eh',\n          },\n        });\n      }}>\n      Click\n    </div>\n  );\n};\n```\n\n# Scalars\n\nZeus supports encoding and decoding scalars\n\n## Decode\n\nThe decode function is called every time a scalar returns from the backend, before passing the result from `Chain` Subscription functions\n\n```graphql\nscalar JSON\nscalar Datetime\ntype Card{\n    info: JSON!\n    createdAt: Datetime\n}\ntype Query:{\n    drawCard: Card!\n}\n```\n\n```typescript\nimport { Chain } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\n\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst data = await chain('query', {\n  scalars: {\n    JSON: {\n      encode: (e: unknown) => JSON.stringify(e),\n      decode: (e: unknown) => JSON.parse(e as string),\n    },\n    Datetime: {\n      decode: (e: unknown) => new Date(e as string),\n      encode: (e: unknown) => (e as Date).toISOString(),\n    },\n  },\n})({\n  drawCard: {\n    info: true,\n  },\n});\n```\n\nThe `data.drawCard.info` will be of type `Date` as provided by the decoder `ReturnType`\n\n## Encode Scalars\n\nYou can also encode scalars before sending them to the backend:\n\n```typescript\nimport { Chain } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\n\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst listCardsAndDraw = await chain('query', {\n  scalars: {\n    JSON: {\n      encode: (e: unknown) => JSON.stringify(e),\n      decode: (e: unknown) => JSON.parse(e as string),\n    },\n    Datetime: {\n      decode: (e: unknown) => new Date(e as string),\n      encode: (e: unknown) => (e as Date).toISOString(),\n    },\n  },\n})({\n  drawCard: {\n    info: true,\n  },\n});\n```\n\nEncoders require values to be encoded to the string and don't work with variables yet.\n\n## Place decoders and encoders in one place for reuse\n\n```typescript\nimport { Chain, ZeusScalars } from './zeus';\n\n// Create a Chain client instance with the endpoint\nconst chain = Chain('https://faker.graphqleditor.com/a-team/olympus/graphql');\nconst scalars = ZeusScalars({\n  JSON: {\n    encode: (e: unknown) => JSON.stringify(e),\n    decode: (e: unknown) => JSON.parse(e as string),\n  },\n  Datetime: {\n    decode: (e: unknown) => new Date(e as string),\n    encode: (e: unknown) => (e as Date).toISOString(),\n  },\n});\n\n// Query the endpoint with Typescript autocomplete for arguments and response fields\nconst listCardsAndDraw = await chain('query', {\n  scalars,\n})({\n  drawCard: {\n    info: true,\n  },\n});\n# Subscriptions\n\nZeus supports [GraphQL over WebSocket subscriptions](https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md) out-of-the-box and is compatible with many popular GraphQL servers.\n\nTwo implementations are supported:\n\n* **graphql-ws**: the modern WebSocket-based transport, implemented by [the graphql-ws package](https://www.npmjs.com/package/graphql-ws). It is also the standard [used by Apollo](https://www.apollographql.com/docs/react/data/subscriptions/#choosing-a-subscription-library)\n* **legacy** (default): a transport based on raw WebSockets\n\n## Generating the client\n\nTo use [graphql-ws](https://www.npmjs.com/package/graphql-ws) as your subscription transport you'll need to do the following:\n\n```\n# Generate the client\nzeus schema.gql ./ --subscriptions graphql-ws\n# Add graphql-ws to your project's dependencies\nnpm install graphql-ws\n```\n\nIf you want to use the **legacy** method, use the `--subscriptions legacy` flag instead. You may need to install [ws](https://www.npmjs.com/package/ws) depending on your setup.\n\nNo matter what implementation you chose, the usage remains the same:\n\n```typescript\n// Create a new Subscription with some authentication headers\nconst wsChain = Subscription('wss://localhost:4000/graphql', {\n  get headers() {\n    return { Authorization: `Bearer ${getToken()}` };\n  },\n});\n\n// Subscribe to new messages\nwsChain('subscription')({\n  message: {\n    body: true,\n  },\n}).on(({ message }) => {\n  console.log(message.body);\n});\n```\n\nIf you need to unsubscribe from a subscription (e.g. you are developing a Single Page App), you can do it as follows:\n\n```typescript\n// Subscribe to new messages\nconst onMessage = wsChain('subscription')({\n  message: {\n    body: true,\n  },\n});\nonMessage.on(({ message }) => {\n  console.log(message.body);\n});\n\n// Close the underlying connection\nonMessage.ws.close();\n```\n\nWhile you can use `wsChain('query')` or `wsChain('mutation')`, [Apollo strongly discourages this practice.](https://www.apollographql.com/docs/react/data/subscriptions/#3-split-communication-by-operation-recommended)","homepage":"https://github.com/graphql-editor/graphql-zeus#readme","repository":"https://github.com/graphql-editor/graphql-zeus"}